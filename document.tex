\documentclass[runningheads]{llncs}

\usepackage[utf8]{inputenc}
\usepackage[ngerman, english]{babel}

\usepackage[T1]{fontenc}
\usepackage{amssymb}
\setcounter{tocdepth}{3}
\usepackage{graphicx}
\usepackage{amsmath}
\usepackage{mathcomp}
\usepackage{url}
\usepackage[chapter]{algorithm}
\usepackage{algorithmic}
\usepackage{subfigure}

\usepackage{appendix}

\usepackage{listings}
\lstset{numbers=left, numberstyle=\tiny, numbersep=5pt}

\newboolean{showcomments}
\setboolean{showcomments}{true} % SET TO false for camera-ready
\ifthenelse{\boolean{showcomments}}
	{	\newcommand{\nbnote}[2]{
			\fbox{\bfseries\sffamily\scriptsize#1}
			{\sf\small$\blacktriangleright$\textit{#2}$\blacktriangleleft$}
		}
	}
	{	\newcommand{\nbnote}[2]{}
	}
\newcommand\todo[1]{\nbnote{TO DO}{#1}}

\begin{document}
\mainmatter
\title{Trends and Concepts in the Software Industry II: \\ Development of Enterprise Software}
\author{Team 5: Providing Data Context During Development}
\institute{Thomas B\"unger, Felix Leupold, Johan Uhle, \\ Patrick Schilf, Lauritz Thamsen, Fabian Tschirschnitz \\[0.1in] Johannes Wust \\
Franziska Haeger, Dr. Anja Bog, Dr. Juergen M\"uller, Prof. Hasso Plattner \\
Hasso-Plattner Institute \\[0.1in]
March 15, 2013}
\date{March 15th, 2013}
\maketitle

\newpage

%Head of Documentation - Patrick: gerade ziehen

\section{Introduction} 
%HoD
%Seminar, Seminarablauf, Thema (= deren how might we question)
%(dabei Bezug zu unserem Subthema aufbauen)
% close with an outline of this document, include references to all sections, see lables

\section{Design Thinking} \label{sec:DESIGN_THINKING}
%Felix
%intro to Design Thinking, its cycle and some intro to our results 

\section{Understand} \label{sec:UNDERSTAND}
%Johan
%Pre seminar interviews

\section{Observe} \label{sec:OBSERVE}
%Johan
%Bachelor projects, conventional development (edit, build, compile)

\section{Point of View} \label{sec:POINT_OF_VIEW}
%Felix
%Persona
%Problem Statement, our how might we

\section{Ideation} \label{sec:IDEATION}
%Felix
%our idea, plus make up some ideas that were not followed

\section{Paper Prototype} \label{sec:PAPER_PROTOTYPE}
%Thomas

\section{User Testing} \label{sec:USER_TESTING}
%Thomas
%Testing
%Feedback

\section{Final Prototype} \label{sec:FINAL_PROTOTYPE}
%Fabi

\section{Implementation Ideas} \label{sec:IMPLEMENTATION_IDEAS}
%Lauritz
Besides providing an unobstrusive user interface, either implemented as a plugin for an existing integrated development environment or else implemented in form of a complete development environment, an implementation of our idea would require components that gather data contexts from actual program runs as well as components that support developers in selecting appropriate and interesting data contexts during development.

% maybe also say something about the user interface for selecting data contexts as well as for seeing and modifying state and queries...

\subsection{Gathering Data Contexts}
As our approach focuses on providing developers with actual runtime data already during development the user interface of an implementation of our approach depends on the availability of such data.
Such data needs to be realistic to be useful to developers.
For this reason, there are two approaches to gathering such runtime data for, for example, showing it when a developer clicks on a line of source code.
Either, a developer's interaction could trigger a deterministic test that covers a specific piece of code that is of interest to the developer or else to capture such data before.
Capturing data beforehand obviously also could rely on test runs, but additionaly could be recorded in live systems used by actual customer and, therefore, providing real runtime data.
Moreover, another advantage of capturing data in advance might be that presenting such recorded data would not depend on running a potentially long-running test, but on fetching the data from a database, which of course also could be an in-memory database.
A reasonable hybrid solution between those two approaches would record data not for every join point in the execution of the application of interest, but could capture data on the level of specific scopes as, for example, methods.
To explore actual runtime situations the recorded data contexts of methods must consist of provided parameters, accessible state, as well as a snapshot of the database at the moment the method is entered.
Snapshots of the database are necessary as the method might modify the database through embedded queries in ways that would not allow subsequent runs of that methods.
That is, the database has to be snapshot at the entry to be able to execute the method and all included queries as often as necessary for exploration during development.
\todo{code example}
%tracing data contexts = snapshots of database and parameters and state, show code examples with parametrized queries
%from test systems with copies of real customer data or from actually deployed and running customer systems
\subsection{Selecting Data Contexts}
%developer always makes the final decision, has to be able to tweak any preselection and also to explore the full extent of gathered data contexts
%automatic sampling using clustering, include clustering image
%tweaking or explicit preselection by involved domain experts

\section{Open Questions} \label{sec:OPEN_QUESTIONS}
%Lauritz
\subsection{Hardware Context}
%runtime characteristics as, for example, query execution profiling depends on the hardware, hardware-aware data contexts, execution on actual hardwares or simulation of hardware, requires research, that is, hardware contexts are future work
\subsection{Query Debugging}
%besides seamless debugging of application-layer code and database-layer queries
%seeing results and profiling information not only for complete queries and distinct subqueries in from clauses, but also for partial queries, obviously not possible to execute arbitrary parts of queries, as, for example, the select query might depend on the presence of a grouping (show example query), therefore, support developers in identifying meaningful parts of queries to, for example, just activate a part of the conditions available in a given where clause, obviously also requires a user interface that allows to select and deselect potentially combinations of just parts of queries
\subsection{Efficient Context Storing}
%many traces result in many contexts, which might be similar, consequentely, identifying and, subsequentely, storing common bases along with context differences might reduce the memory consumption of a context database significantly, for the database snapshots it might be possible to leverage HANA's time travel feature

\section{Conclusion} \label{sec:CONCLUSION}
%HoD

%\bibliography{references}
\bibstyle{splncs03}
\bibliographystyle{splncs03}

\end{document}
