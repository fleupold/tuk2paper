%!TEX root = ../document.tex
\section{Implementation Ideas} \label{sec:IMPLEMENTATION_IDEAS}
%Lauritz
Besides providing an unobstrusive user interface, either implemented as a plugin for an existing integrated development environment or else implemented in form of a complete development environment, an implementation of our idea would require components that gather data contexts from actual program runs as well as components that support developers in selecting appropriate and interesting data contexts during development.

% maybe also say something about the user interface for selecting data contexts as well as for seeing and modifying state and queries...

\subsection{Gathering Data Contexts}
As our approach focuses on providing developers with actual runtime data already during development the user interface of an implementation of our approach depends on the availability of such data.
Such data needs to be realistic to be useful to developers.
For this reason, there are two approaches to gathering such runtime data for, for example, showing it when a developer clicks on a line of source code.
Either, a developer's interaction could trigger a deterministic test that covers a specific piece of code that is of interest to the developer or else to capture such data before.
Capturing data beforehand obviously also could rely on test runs, but additionaly could be recorded in live systems used by actual customer and, therefore, providing real runtime data.
Moreover, another advantage of capturing data in advance might be that presenting such recorded data would not depend on running a potentially long-running test, but on fetching the data from a database, which of course also could be an in-memory database.
A reasonable hybrid solution between those two approaches would record data not for every join point in the execution of the application of interest, but could capture data on the level of specific scopes as, for example, methods.
To explore actual runtime situations the recorded data contexts of methods must consist of provided parameters, accessible state, as well as a snapshot of the database at the moment the method is entered.
Snapshots of the database are necessary as the method might modify the database through embedded queries in ways that would not allow subsequent runs of that methods.
That is, the database has to be snapshot at the entry to be able to execute the method and all included queries as often as necessary for exploration during development.
\todo{code example}
%tracing data contexts = snapshots of database and parameters and state, show code examples with parametrized queries
%from test systems with copies of real customer data or from actually deployed and running customer systems
\subsection{Selecting Data Contexts}
These tracing approaches generates potentially numerous data contexts.
When our tool would trace real deployed systems, it could capture any number of data contexts for a particular scope.
Given our system captures a data context for each method call and a specific method is, for example, called whenever a user clicks a button, the system would capture an arbitrarily high number of data contexts for this situation.
Further, even when our tool only traces test execution on replicated databases, particular scopes might not only be executed in many test cases, but also multiple times in a single test case as, for example, obviously the case with methods called from loop bodies.
For these reasons, a developer using our tool might be confronted with many data contexts for certain situations.
However, as the number of available data contexts might be arbitrarily high and data context from the same trace might also overlap considerably, presenting all data contexts to the developer probably reduces usability significantly. 
Approaches addressing this issue include automatic selection of interesting samples after clustering all data contexts, preselection of interesting data contexts through experts, and combinations of those two methods.
Clustering could be based on at several dimensions, including \todo{some image for the clustering}:
\begin{itemize}
  \item size of the context's database
  \item control flow that lead to this context
  \item execution time of the context's scope
\end{itemize}
Nevertheless, even aided through automatic clustering or manual preselections, our tools should probably also support developers in exploring the full extent of available contexts and make the final decision on which specific data context they want to use during development.