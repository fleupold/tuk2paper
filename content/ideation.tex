%!TEX root = ../document.tex

\section{Ideation}
\label{sec:IDEATION}

Starting from our POV we had several rounds of brainstorming in which we came up with lots of savvy, silly, crazy and wild ideas. In this section we will present a very limited subset of these ideas. The ones presented have gotten the most attention by our team and have actually been thought through to a certain extent.

\subsection{Data Preview in the Editor}
Our final "How might we question..." asked how we can help our persona to see the impact of her code on the data that it is working with right in the IDE. We looked at existing debugging environments. In a debug mode you can see the allocation of all variables with data and the impact your code has on that data for every instruction. However, unless the debugger has hot-debugging capabilities, you cannot change the allocation of a variable or the control flow of your program. Even in hot debugging environments this feature is not used to write code.
Given a runtime environment, which could be captured from test cases or previous executions, it is possible to bind parameters and state even in edit mode. Therefore, it is possible to show all the information available in debug mode also at coding time. This would dramatically decrease the development cycle of \textit{coding, build, test} (cf. Section \ref{sec:OBSERVE}) as errors can be detected while you initially write the code. A technique called In-System Programming allows to program some microcontrollers and other embedded devices under test \cite{herrmann2002apparatus}.
We decided to take this idea and apply it to software development in general, and database development in particular.  By clicking on a query in the code editor, our persona shall be able to see the results of that query for a pre-defined runtime environment.

\subsection{Performance Evaluation in the Editor}
Since our Persona is developing performance critical application it is very important for her that her applications can handle the big data set they working with. Since Amber is not an SQL performance expert, meaning that she might not able to predict the impact of different SQL operators on performance there has to be a tools showing performances for different query formulations. Since she does not want to switch contexts, this tools has to be build right into her IDE. Our idea is a tools that shows the result set size and query execution time whenever you click on query. It actually executes the query against a real customer data set. This way the results are reliable.
Using a kind of time machine like view for different versions of the query, Amber can instantly see how changes in the SQL query affect the size of the result set and the time it needed to be fetched.
In our final solution we combine this idea with the previous one.

\subsection{Code Generation in HANA Studio}
The HANA Studio is a tool that allows to interact with a HANA instance, execute queries and show the results. Since our persona switches to the Studio, whenever she is trying to fine-tune the performance of a query we thought it would be a good idea if we allowed Amber to create a code snippet within the Studio that already contains language specific code that she can copy into her IDE. In her application there are a few lines of boiler plate code for each database access: Creating a connection to the database, getting a cursor, executing the statement and fetching and iterating over the results. This code could be auto-generated by the studio.

However, the boiler plate code is not always the exact same and might be tackled by DRY\footnote{don't repeat yourself} application design.
Also, because the studio itself needs a lot of context switches to change and view query results, and code is naturally written in the IDE we decided not to follow this idea. 

\subsection{Making E-Mail more Expensive}
During our first interviews we found out that a lot of the interruptions are due to incoming emails. We also found out that the answers to a large amount of questions asked via email can be found by looking for it in knowledge management systems such as internal wikis. However, the act of opening a mail program and writing an email is much more convenient than searching through the different knowledge sources and reading all articles related to the question. This is why many emails with redundant questions are written, each of which causing a developer to disrupt his development flow.

To tackle this problem we wanted to make e-mail communication more expensive. Employees would get credits and each email would cost a certain amount of credits, depending on whether this question was useful or unnecessary. Credits could be earned by answering emails and may be optionally turned into a monetary benefit.
This system should be an incentive to first search for a solution on the Internet or Intranet before bothering a coworker with an unnecessary question.
However, communication is the key to successful team work, which is why making e-mail more expensive might not be well perceived by decision makers. Our solution would differentiate between "good" and "bad" communication which is a categorization that might be hard to make.

Atos, an IT services and consulting buyout firm from Siemens, has pioneered in this field by removing all internal emails until the end of 2013 in the context of their Zero Email campaign \cite{zero_email}.

We considered this idea being too risky and had other ideas that could make an even bigger impact on our persona's efficiency. This is why we decided to not follow this idea.

\paragraph{}
Our eventual idea is to help Amber understand the impact of her code on the underlying data without having to switch contexts by providing an Eclipse plugin that allows her to preview query results and execution time right in her editor. If she makes any changes she can compare information for the previous query formulation with the new one, allowing her to directly see the impact of her code while she is writing it.