%!TEX root = ../document.tex

\section[Ideation (Author: Felix Leupold)]{Ideation}
\label{sec:IDEATION}

Starting from our POV we held several rounds of brainstorming in which we came up with lots of savvy, silly, crazy and wild ideas. In this section we will present a very limited subset of these ideas. Out of this pool some attracted our attention more than others. The following section presents those approaches, that we, though not neccessariliy to the very end, thought through to a certain extent and thus believe to be potentially valuable.

\subsection{Data Preview in the Editor}
Our final \emph{"How might we question..."} asks how we could help our Persona to understand the impact of her code on the corresponding data right from within the IDE. Looking at into existing debugging environments, we found that the debug mode usually allows for exploration of all variables with their data allocation. Thus, the impact code has on that data can be exposed for every instruction. Unfortunately, unless the debugger offers hot-debugging capabilities, it is impossible to change the allocation of a variable or the control flow of your program. Even in hot-debugging environments this feature is not used to write code.
Given a runtime environment, which could be captured from test cases or previous executions, it is possible to bind parameters and states even in edit mode. Therefore, it is possible to show all the information available in debug mode at coding time. This would dramatically simplify the development cycle of \textit{coding, build, test} (cf. Section \ref{sec:OBSERVE}) as errors can be detected far earlier in the process. A technique called \emph{In-System Programming} allows to program some micro-controllers and other embedded devices under test \cite{herrmann2002apparatus}.
We decided to take this concept to the next level by applying it to software development in general, and databases in particular.  In our vision, our Persona would be be able to explore the results of a query for a pre-defined runtime environment simply by selecting it in the code editor.

\subsection{Performance Evaluation in the Editor}
Since our Persona is developing performance critical applications it is crucial for her applications to handle the big data sets they work on. As already mentioned, Amber is not an SQL performance expert in a way that is not intuitive for her to figure out the impact of the different operators on performance. To support her, one might think of a tool to instantly display performance values for different query formulations. To avoid Contexts Switches, this tools would be build right into her IDE. In our idea the tool displays the result set size and query execution time whenever you click on a query. Technically, it would execute the query against a real customer data set to ensure reliability of the results.
Using a kind of time machine like view for different versions of the query, Amber can instantly see how changes in the SQL query affect the size of the result set and the time needed for it to be fetched.
In our final solution we combine this idea with the previous one.

\subsection{Code Generation in HANA Studio}
HANA Studio is a tool which allows to interact with a HANA instance, execute queries and show the results. Our Persona switches to the Studio, whenever she is trying to fine-tune a query's performance. In her application there are a few lines of boiler plate code for each database access: Creating a connection to the database, getting a cursor, executing the statement and fetching and iterating over the results. In order to speed up this repeating process for Amber, we thought a tool to auto-generate code snippets within the Studio that already contained language specific code and that Amber could then copy into her IDE.

However, the boiler plate code is not always the exact same and might be tackled by DRY\footnote{don't repeat yourself} application design.
Additionally, due to the fact, that the Studio itself involves numerous Context Switches to change and view query results, and because code is naturally written in the IDE we decided not to further investigate this idea. 

\subsection{Making E-Mail more Expensive}
During our first interviews we found out that many interruptions are cause by incoming emails. Even more, our people told us, that the many of these emails relate to questions the answers to which reside in knowledge management systems such as internal wikis. Apparently, the act of opening a mail program and composing an email seems to be much more convenient than searching through the different knowledge sources and reading all articles related to the question. As a result, many emails with redundant questions are sent, each of which causes someone  to disrupt his or her workflow.

To address this issue we thought of ways to make email communication more expensive. Employees would get a budget of credits to send emails, each of which defining its own price, depending on the usefulness of the question. Credits could be earned by answering emails and may be optionally turned into a monetary benefit.
The goal of this system is to encourage people to search for a solution on the Internet or Intranet before bothering a co-worker with an unnecessary question.
However, communication is the key to successful team work, which is why making email more expensive might not be well perceived by decision makers. An (automated) categorization of emails into "good" and "bad" communication might, however, be a tough one to implement.

Interestingly though, an IT services and consulting buyout firm from \emph{Siemens}, has pioneered in this field by removing all internal emails until the end of 2013 in the context of their \emph{Zero Email campaign} \cite{zero_email}.

All in all we considered this idea to be too risky and instead chose to dig into other ideas which we assumed to have an even bigger impact on our Persona's efficiency. We still consider the approach as an interesting experiment.

\paragraph{}
Our eventual idea is to help Amber understand the impact of her code on the underlying data without having to switch contexts. Technically, this would be an Eclipse plugin that allows her to preview query results and execution time right in her editor. Any adjustments she makes to a query, she can compare to information on previous query formulations. This allows her to directly realize the impact of her code while she is writing it.