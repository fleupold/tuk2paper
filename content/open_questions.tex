%!TEX root = ../document.tex
\section{Open Questions} \label{sec:OPEN_QUESTIONS}
%Lauritz
In the future, we would like to investigate how seamless and semantic debugging of complete and partial SQL queries could be realized and integrated with our idea, whether and how the actual hardware configurations could be captured as part of the data contexts, and how data contexts could be stored efficiently.

\subsection{Query Debugging}
Query debugging should be seamless and provide immediate feedback while understanding and developing application code and database queries.
Developers should, thus, not be required to copy complete or parts of embedded queries from their application code to active database sessions.
Instead, a debugger should be able to step through and evaluate both application code and embedded database queries without interrupting the developer through changing the user interactions or interface.
A unified user interface for understanding both types of code should present return values, show basic profiling information, and allow to explore involved data.
Additionally, developers might benefit from exploring and debugging parts of queries.
However, as parts of SQL queries cannot necessarily be evaluated independently, but instead might depent on other parts of the queries, developers potentially need to select multiple parts in conjunction.
Given the following example query, the \texttt{WHERE} as well as the \texttt{SELECT} clause both rely on the \texttt{JOIN} in Line 2 of this example.
\lstset{language=SQL}
\begin{lstlisting}
  SELECT products.name, SUM (orders.price) as pricemake
  FROM orders JOIN products ON orders.pid=products.pid
  WHERE orders.year = 2012 and products.manufacturer = "HPI"
  GROUP BY product
\end{lstlisting}
An ideal data context debugger could aid developers also in selecting meaningful combinations of automatically identified, meaningful parts of database queries.

\subsection{Hardware Context}
Our idea focuses on showing actual results and basic profiling information right next to code and queries.
Assuming deadlock-free deterministic code, the results of queries should be independent of the underlying hardware.
However, the performance characteristics might depend significantly on the executing hardware.
Therefore, our approach would benefit from incorporating the impact of different hardware by extending our context recording to also capture hardware configurations.
Further efforts in this directions should, consequentely, focus on capturing, storing, and applying hardware contexts.
Such hardware contexts could be used to either run statements on appropriate hardware or to simulate the impact of different hardware.

Another open question is whether data contexts should be tied to particular hardware contexts during our tracing.
Developers could gain insights from combining data contexts and hardware contexts freely to see how their application performs in many different situations.
However, bundling both contexts emphasizes optimizing performance for real usage.

\subsection{Context Representation}
As our approach potentially results in many similar data contexts for any given code section, actually storing data contexts could probably exploit these similarities between data contexts.
That is, an implementation could find similar data contexts, identify common base contexts, and, consequentely, store base contexts once and only the differences to those base contexts for each particular context.

As data contexts from the same traces using the same database potentially always overlap at least in their database snapshot, but probably also in the accessible state that needs to be captured, marking data contexts with an identifier for a particular trace might allow to identify similar data contexts faster.

Further, the efficiency of storing data contexts could proably also leverage advanced database features as, for example, \emph{SAP HANA's Time Travel} feature~\footnote{\url{http://help.sap.com/hana/html/sql_create_table_history_time_travel.html}, retrieved March 12, 2013} that allows to reset the database to a specific moment in time.
Given this feature, an implementation would need to store only timestamps to establish the database part of data contexts instead of actual database snapshots.
