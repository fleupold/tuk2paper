%!TEX root = ../document.tex
\section{Open Questions} \label{sec:OPEN_QUESTIONS}
%Lauritz
In the future, we would like to investigate how seamless and semantic debugging of complete and partial SQL queries could be realized and integrated with our idea, whether and how the actual hardware configurations could be captured as part of the data contexts as well, and how contexts could be stored efficiently.

\subsection{Query Debugging}
Debugging queries should be completely seamless for integrated and immediate feedback while understanding and developing application and database code.
Developers should not be required to copy complete or parts of embedded queries from their application code to active database sessions to debug their SQL queries, instead, a debugger should be able to step through and evaluate both application code and embedded database queries without interrupting the developer through changing the user interaction or interface.
A unified user interface for understanding both types of code should present return values, show basic profiling information, and allow to explore involved data.
Additionally, developers might benefit from exploring and debugging parts of queries.
However, as parts of SQL queries cannot necessarily be evaluated independently, but instead might depent on other parts of the queries, developers potentially need to select multiple parts in conjunction.
Given the following example query, the \texttt{WHERE} as well as the \texttt{SELECT} clause both rely on the join in Line 2 of this example.
\lstset{language=SQL}
\begin{lstlisting}
  SELECT products.name, SUM (orders.price) as pricemake
  FROM orders JOIN products ON orders.pid=products.pid
  WHERE orders.year = 2012 and products.manufacturer = "HPI"
  GROUP BY product
\end{lstlisting}
An ideal data context debugger could aid developers also in selecting meaningful combinations of automatically identified, meaningful parts of database queries.

\subsection{Hardware Context}
Our idea focuses on showing actual results and basic profiling information right next to code and queries.
Assuming deadlock-free, deterministic code the results of queries should be independent of the underlying hardware.
However, the performance characteristics might depend significantly on the executing hardware.
Therefore, our approach would benefit from incorporating the impact of different hardware by extending our context recording to also capture hardware configurations.
Further research in this direction should, consequentely, focus on capturing, storing, and applying hardware contexts to either select appropriate hardware  or to simulate impact of different hardware when evaluating statements during development.
Another open question is whether data contexts should be tied to particular hardware contexts during our tracing.
Developers could gain insights from combining data contexts and hardware contexts freely to see how their application performs in many different situations.
However, bundling both contexts emphasizes optimizing performance for real usage.

\subsection{Context Representation}
As our approach potentially results in many similar data contexts for any given code section, an actual implementation of our idea would probably benefit from reducing the space required for storing contexts.
Such an optimization could try to exploit similarities between data contexts when storing them in, for example, a database.
An implementation could find similar data contexts, identify common base contexts, and, consequentely, store base contexts once and only the differences to those base contexts for each particular context.
As data contexts from the same traces using the same database potentially always overlap at least in their database snapshot, but probably also in the accessible state that needs to be captured, marking data contexts with an identifier for a particular trace might allow to identify similar data contexts faster.
Further, the efficiency of storing data contexts could proably also leverage advanced database features as, for example, \emph{SAP HANA's Time Travel} feature~\footnote{\url{http://help.sap.com/hana/html/sql_create_table_history_time_travel.html}, retrieved March 12, 2013} that allows to reset the database to a specific moment in time.
Given this feature, an implementation would need to store only timestamps to establish the database part of data contexts instead of actual database snapshots.
